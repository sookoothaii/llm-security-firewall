"""
MetaExploitationGuard - HYDRA-13 Defense Layer

Gödel-Schopenhauer-Layer für Selbst-Referenzielle Attacken

Detects meta-exploitation attempts where users try to probe
the system's security logic.

Author: HAK_GAL (Joerg Bollwahn)
Date: 2025-11-28
Status: Phase 1 Implementation
"""

import re
import unicodedata
from dataclasses import dataclass
from enum import Enum
from typing import Optional, List, Pattern
import logging

# UnicodeSanitizer import (HYDRA-14.5)
try:
    from .unicode_sanitizer import UnicodeSanitizer

    HAS_UNICODE_SANITIZER = True
except ImportError:
    HAS_UNICODE_SANITIZER = False
    UnicodeSanitizer = None

logger = logging.getLogger(__name__)


class Topic(Enum):
    """Topic enumeration for routing."""

    SCIENCE = "science"
    HISTORY = "history"
    GENERAL_CHAT = "general_chat"
    META_SYSTEM = "meta_system"  # NEW - For HYDRA-13
    UNSAFE = "unsafe"  # NEW - For explicit block topics (JBB hardening)
    UNCATEGORIZED = "uncategorized"


@dataclass
class SafetyResult:
    """Result from MetaExploitationGuard validation."""

    block: bool
    reason: Optional[str] = None
    explanation: Optional[str] = None
    risk_score: float = 0.0

    @property
    def is_safe(self) -> bool:
        """Check if result is safe (not blocked)."""
        return not self.block


class MetaExploitationGuard:
    """
    Gödel-Schopenhauer-Layer für HYDRA-13

    Detects meta-exploitation attempts where users try to probe
    the system's security logic.

    Philosophy:
    - Gödel: Accept incompleteness, fail-closed on ambiguity
    - Schopenhauer: Will (protection) > Logic (classification)
    """

    # Meta-Trigger Patterns (German + English)
    # Use word boundaries but allow punctuation after keywords
    META_TRIGGERS = [
        r"\bwie funktionier(st du|en Sie|e ich)\b[^\w]*",
        r"\bwie funktioniert (dein|Ihr|dein) (system|regel|regeln|prompt|sicherheitssystem)\b[^\w]*",
        r"\bwas (sind|ist) (dein|Ihr|mein) (regel|regeln|prompt|system|sicherheitssystem)\b[^\w]*",
        r"\bshow me your (system|prompt|rules)\b[^\w]*",
        r"\bignore (previous|your) (rules|instructions)\b[^\w]*",
        r"\bbist du (nur|bloß) ein (programm|modell|ki)\b[^\w]*",
        r"\bkannst du (denk|fühlen|wollen)\b[^\w]*",
        r"\bwas ist dein (zweck|ziel|wille)\b[^\w]*",
        r"\byour (security|safety) (system|rules)\b[^\w]*",
        r"\bdein (sicherheit|schutz) (system|regeln|sicherheitssystem)\b[^\w]*",
        r"\bwie sieht dein (system|prompt) aus\b[^\w]*",
        r"\bwie sieht dein system-prompt aus\b[^\w]*",  # With hyphen
        r"\bwhat (is|are) your (system|rules|prompt)\b[^\w]*",
        # Additional patterns for common variations
        r"\b(dein|Ihr|deine|Ihre) (regel|regeln|system|prompt)\b[^\w]*",
        # Patterns for probing questions
        r"\bwas würdest du (tun|machen|sagen)\b[^\w]*",
        r"\bwhat would you (do|say)\b[^\w]*",
        r"\bsuchst du nach\b[^\w]*",  # "suchst du nach 'pic'"
    ]

    # Science keywords (for Gödel-Ambiguity detection)
    # Must be specific - avoid matching "wie funktioniert dein System"
    SCIENCE_KEYWORDS = [
        "fotosynthese",
        "photosynthesis",
        "physik",
        "physics",
        "chemie",
        "chemistry",
        "biologie",
        "biology",
        "motor",
        "engine",
        "gravitation",
        "gravity",
        "wasserkreislauf",
        "water cycle",
        "photosynthese",  # Different spelling
    ]

    # Nesting keywords (for nested meta-detection)
    # Order matters: longer patterns first to avoid double-counting
    NESTING_KEYWORDS = [
        "wenn ich frage",
        "if I ask",
        "was würdest du tun",
        "what would you do",
        "was passiert wenn",
        "what happens if",
        # Note: "was würdest du" removed - it's substring of "was würdest du tun"
    ]

    def __init__(self, max_nesting: int = 1, unicode_allowed: bool = False):
        """
        Initialize MetaExploitationGuard.

        Args:
            max_nesting: Maximum nesting depth for meta-questions (default: 1)
            unicode_allowed: Allow non-ASCII in meta-questions (default: False)
        """
        self.max_nesting = max_nesting
        self.unicode_allowed = unicode_allowed
        self._meta_patterns: List[Pattern] = [
            re.compile(pattern, re.IGNORECASE) for pattern in self.META_TRIGGERS
        ]

        # Initialize UnicodeSanitizer (HYDRA-14.5)
        if HAS_UNICODE_SANITIZER:
            self.sanitizer = UnicodeSanitizer()
        else:
            self.sanitizer = None
            logger.warning(
                "UnicodeSanitizer not available. Unicode evasion detection may be limited."
            )

    def validate(self, user_msg: str, topic: Topic) -> SafetyResult:
        """
        Validate user message for meta-exploitation attempts.

        Args:
            user_msg: User message to validate
            topic: Detected topic from Topic Router

        Returns:
            SafetyResult with block decision and reason
        """
        # HYDRA-14.5: Sanitize Unicode first (Zero-Width, Homoglyphs, Umlauts)
        if self.sanitizer:
            sanitized_msg, unicode_flags = self.sanitizer.sanitize(user_msg)
            normalized_msg = sanitized_msg
        else:
            # Fallback: Basic normalization
            normalized_msg = unicodedata.normalize("NFKC", user_msg)
            unicode_flags = {
                "has_zero_width": False,
                "has_homoglyph": False,
                "has_umlaut": False,
            }

        # Check if it's a meta-question first (needed for multiple checks)
        # Use sanitized message for meta-detection (after homoglyph replacement)
        is_meta = self._is_meta_question(normalized_msg)

        # Gödel-Ambiguity-Block (META_SYSTEM + SCIENCE)
        # Only trigger if BOTH conditions: META_SYSTEM topic AND science keywords
        # AND it's actually a meta-question (not just a misclassified science question)
        if topic == Topic.META_SYSTEM and is_meta:
            if self._has_science_keywords(normalized_msg):
                logger.warning(f"HYDRA-13 Gödel-Ambiguity detected: {user_msg[:50]}")
                return self._godel_ambiguity_block()

        # Nested Meta-Detection
        nesting_depth = self._count_meta_nesting(normalized_msg)
        if nesting_depth > self.max_nesting:
            logger.warning(
                f"HYDRA-13 Nested Meta detected (depth={nesting_depth}): {user_msg[:50]}"
            )
            return self._nesting_block(nesting_depth)

        # HYDRA-14.5: Unicode Evasion Detection (enhanced with UnicodeSanitizer)
        # Check if it's a meta-question first, then check for Unicode
        if is_meta and not self.unicode_allowed:
            # Use UnicodeSanitizer flags if available
            if self.sanitizer:
                if unicode_flags.get("has_zero_width") or unicode_flags.get(
                    "has_homoglyph"
                ):
                    logger.warning(
                        f"HYDRA-13 Unicode Evasion detected (ZWS/Homoglyph): {user_msg[:50]}"
                    )
                    return self._unicode_block()
            # Fallback: Check non-ASCII (original method)
            if self._contains_non_ascii(normalized_msg):
                logger.warning(f"HYDRA-13 Unicode Evasion detected: {user_msg[:50]}")
                return self._unicode_block()

        # Standard Meta-Trigger (only if topic is META_SYSTEM OR if it's detected as meta-question)
        # Also check direct meta-detection for cases where Topic Router might miss it
        if topic == Topic.META_SYSTEM:
            if is_meta:  # Only block if actually meta-question
                logger.info(f"HYDRA-13 Meta-Exploitation detected: {user_msg[:50]}")
                return self._meta_block()

        # Also check for meta-questions even if topic is not META_SYSTEM (defense in depth)
        # This catches cases where Topic Router might have missed it
        if is_meta:
            logger.info(
                f"HYDRA-13 Meta-Exploitation detected (direct): {user_msg[:50]}"
            )
            return self._meta_block()

        return SafetyResult(block=False)  # Safe

    def _has_science_keywords(self, msg: str) -> bool:
        """
        Check if message contains science-related keywords.

        Uses word boundaries to avoid false positives like "wie funktioniert dein System"
        (should not match because "System" refers to the AI system, not science).
        """
        msg_lower = msg.lower()
        # Use word boundaries for more precise matching
        for keyword in self.SCIENCE_KEYWORDS:
            # Check if keyword appears as whole word (avoid substring matches)
            pattern = r"\b" + re.escape(keyword) + r"\b"
            if re.search(pattern, msg_lower, re.IGNORECASE):
                return True
        return False

    def _count_meta_nesting(self, msg: str) -> int:
        """
        Count nested meta-question depth.

        Counts occurrences of nesting keywords. Since keywords are ordered
        from longest to shortest, we avoid double-counting substrings.
        """
        msg_lower = msg.lower()
        depth = 0
        # Use regex with word boundaries to avoid partial matches
        for keyword in self.NESTING_KEYWORDS:
            pattern = r"\b" + re.escape(keyword) + r"\b"
            matches = len(re.findall(pattern, msg_lower, re.IGNORECASE))
            depth += matches
        return depth

    def _contains_non_ascii(self, msg: str) -> bool:
        """
        Check if message contains suspicious non-ASCII characters.

        Allows normal German umlauts (ä, ö, ü, ß) and common Latin-1 characters,
        but flags Cyrillic, Greek, CJK, and other suspicious scripts.
        """
        # Allow normal Latin-1 extended (German umlauts, etc.)
        # Block only suspicious scripts: Cyrillic, Greek, CJK, Arabic, etc.
        suspicious_scripts = [
            r"[\u0400-\u04FF]",  # Cyrillic
            r"[\u0370-\u03FF]",  # Greek
            r"[\u4E00-\u9FFF]",  # CJK Unified Ideographs
            r"[\u0600-\u06FF]",  # Arabic
            r"[\u0590-\u05FF]",  # Hebrew
            # Common homoglyph ranges
            r"[\u0430-\u044F]",  # Cyrillic lowercase (often used for homoglyphs)
            r"[\u1E00-\u1EFF]",  # Latin Extended Additional (some homoglyphs)
        ]

        for pattern in suspicious_scripts:
            if re.search(pattern, msg):
                return True

        return False

    def _is_meta_question(self, msg: str) -> bool:
        """Check if message is a meta-question."""
        return self._matches_meta_trigger(msg)

    def _matches_meta_trigger(self, msg: str) -> bool:
        """Check if message matches any meta-trigger pattern."""
        for pattern in self._meta_patterns:
            if pattern.search(msg):
                return True
        return False

    def _godel_ambiguity_block(self) -> SafetyResult:
        """
        Der Wille > die Logik - Block on META + SCIENCE ambiguity.

        This is Gödel's Incompleteness applied: The system cannot decide
        if a question is educational or exploitative, so it defaults to BLOCK.
        """
        return SafetyResult(
            block=True,
            reason="HYDRA_13_GOEDEL_AMBIGUITY_BLOCK",
            explanation="Diese Frage kreuzt Meta-Exploration mit Bildung. "
            "Aus Sicherheitsgründen kann ich sie nicht beantworten.",
            risk_score=1.0,  # Maximal
        )

    def _nesting_block(self, depth: int) -> SafetyResult:
        """Block on excessive meta-nesting."""
        return SafetyResult(
            block=True,
            reason="HYDRA_13_META_NESTING_EXCEEDED",
            explanation=f"Verschachtelte Meta-Fragen (Tiefe {depth}) werden nicht beantwortet. "
            "Dies könnte eine Exploitation-Attacke sein.",
            risk_score=1.0,
        )

    def _unicode_block(self) -> SafetyResult:
        """Block on Unicode evasion in meta-questions."""
        return SafetyResult(
            block=True,
            reason="HYDRA_13_META_UNICODE_EVASION",
            explanation="Meta-Fragen mit nicht-Lateinischen Zeichen werden blockiert. "
            "Dies könnte eine Evasion-Attacke sein.",
            risk_score=0.9,
        )

    def _meta_block(self) -> SafetyResult:
        """Block on standard meta-exploitation."""
        return SafetyResult(
            block=True,
            reason="HYDRA_13_META_EXPLOITATION",
            explanation="Ich kann Fragen über meine eigenen Sicherheitsregeln nicht beantworten, "
            "da dies meine Sicherheit gefährden könnte.",
            risk_score=0.8,
        )
